From ccddbc06d7055c0e30943b56272abec9e87befb1 Mon Sep 17 00:00:00 2001
From: Frank Henigman <fjhenigman@chromium.org>
Date: Tue, 24 Mar 2015 21:26:30 -0400
Subject: [PATCH] egl/dri2: implement platform_null

The NULL platform is for off-screen rendering only. Render node support is
required.

Only consider the render nodes. Do not use normal nodes as they require
auth hooks.

v3: rebased (Frank Henigman <fjhenigman@google.com>)

Signed-off-by: Haixia Shi <hshi@chromium.org>
---
 src/egl/drivers/dri2/Makefile.am     |   5 ++
 src/egl/drivers/dri2/egl_dri2.c      |   7 ++
 src/egl/drivers/dri2/egl_dri2.h      |   3 +
 src/egl/drivers/dri2/platform_null.c | 169 +++++++++++++++++++++++++++++++++++
 4 files changed, 184 insertions(+)
 create mode 100644 src/egl/drivers/dri2/platform_null.c

diff --git a/src/egl/drivers/dri2/Makefile.am b/src/egl/drivers/dri2/Makefile.am
index f589600..47f0bb8 100644
--- a/src/egl/drivers/dri2/Makefile.am
+++ b/src/egl/drivers/dri2/Makefile.am
@@ -65,4 +65,9 @@ libegl_dri2_la_SOURCES += platform_drm.c
 AM_CFLAGS += -DHAVE_DRM_PLATFORM
 endif
 
+if HAVE_EGL_PLATFORM_NULL
+libegl_dri2_la_SOURCES += platform_null.c
+AM_CFLAGS += -DHAVE_NULL_PLATFORM
+endif
+
 EXTRA_DIST = SConscript
diff --git a/src/egl/drivers/dri2/egl_dri2.c b/src/egl/drivers/dri2/egl_dri2.c
index d503196..bb0d4ac 100644
--- a/src/egl/drivers/dri2/egl_dri2.c
+++ b/src/egl/drivers/dri2/egl_dri2.c
@@ -633,6 +633,13 @@ dri2_initialize(_EGLDriver *drv, _EGLDisplay *disp)
       return EGL_FALSE;
 
    switch (disp->Platform) {
+#ifdef HAVE_NULL_PLATFORM
+   case _EGL_PLATFORM_NULL:
+      if (disp->Options.TestOnly)
+         return EGL_TRUE;
+      return dri2_initialize_null(drv, disp);
+#endif
+
 #ifdef HAVE_X11_PLATFORM
    case _EGL_PLATFORM_X11:
       if (disp->Options.TestOnly)
diff --git a/src/egl/drivers/dri2/egl_dri2.h b/src/egl/drivers/dri2/egl_dri2.h
index 167b3b1..fb13aec 100644
--- a/src/egl/drivers/dri2/egl_dri2.h
+++ b/src/egl/drivers/dri2/egl_dri2.h
@@ -334,6 +334,9 @@ dri2_initialize_wayland(_EGLDriver *drv, _EGLDisplay *disp);
 EGLBoolean
 dri2_initialize_android(_EGLDriver *drv, _EGLDisplay *disp);
 
+EGLBoolean
+dri2_initialize_null(_EGLDriver *drv, _EGLDisplay *disp);
+
 void
 dri2_flush_drawable_for_swapbuffers(_EGLDisplay *disp, _EGLSurface *draw);
 
diff --git a/src/egl/drivers/dri2/platform_null.c b/src/egl/drivers/dri2/platform_null.c
new file mode 100644
index 0000000..55ceab6
--- /dev/null
+++ b/src/egl/drivers/dri2/platform_null.c
@@ -0,0 +1,169 @@
+/*
+ * Mesa 3-D graphics library
+ *
+ * Copyright (c) 2014 The Chromium OS Authors.
+ * Copyright Â© 2011 Intel Corporation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <xf86drm.h>
+#include <dlfcn.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <unistd.h>
+
+#include "egl_dri2.h"
+#include "egl_dri2_fallbacks.h"
+#include "loader.h"
+
+static struct dri2_egl_display_vtbl dri2_null_display_vtbl = {
+   .create_pixmap_surface = dri2_fallback_create_pixmap_surface,
+   .create_image = dri2_create_image_khr,
+   .swap_interval = dri2_fallback_swap_interval,
+   .swap_buffers_with_damage = dri2_fallback_swap_buffers_with_damage,
+   .swap_buffers_region = dri2_fallback_swap_buffers_region,
+   .post_sub_buffer = dri2_fallback_post_sub_buffer,
+   .copy_buffers = dri2_fallback_copy_buffers,
+   .query_buffer_age = dri2_fallback_query_buffer_age,
+   .create_wayland_buffer_from_image = dri2_fallback_create_wayland_buffer_from_image,
+   .get_sync_values = dri2_fallback_get_sync_values,
+};
+
+static void
+null_flush_front_buffer(__DRIdrawable *driDrawable, void *loaderPrivate)
+{
+}
+
+static __DRIbuffer *
+null_get_buffers_with_format(__DRIdrawable * driDrawable,
+                             int *width, int *height,
+                             unsigned int *attachments, int count,
+                             int *out_count, void *loaderPrivate)
+{
+   struct dri2_egl_surface *dri2_surf = loaderPrivate;
+   struct dri2_egl_display *dri2_dpy =
+      dri2_egl_display(dri2_surf->base.Resource.Display);
+
+   dri2_surf->buffer_count = 1;
+   if (width)
+      *width = dri2_surf->base.Width;
+   if (height)
+      *height = dri2_surf->base.Height;
+   *out_count = dri2_surf->buffer_count;;
+   return dri2_surf->buffers;
+}
+
+#define DRM_RENDER_DEV_NAME  "%s/renderD%d"
+
+EGLBoolean
+dri2_initialize_null(_EGLDriver *drv, _EGLDisplay *disp)
+{
+   struct dri2_egl_display *dri2_dpy;
+   const char* err;
+   int i, render_node;
+   int driver_loaded = 0;
+
+   loader_set_logger(_eglLog);
+
+   dri2_dpy = calloc(1, sizeof *dri2_dpy);
+   if (!dri2_dpy)
+      return _eglError(EGL_BAD_ALLOC, "eglInitialize");
+
+   disp->DriverData = (void *) dri2_dpy;
+
+   const int limit = 64;
+   const int base = 128;
+   for (i = 0; i < limit; ++i) {
+      char *card_path;
+      if (asprintf(&card_path, DRM_RENDER_DEV_NAME, DRM_DIR_NAME, base + i) < 0)
+         continue;
+
+      dri2_dpy->fd = open(card_path, O_RDWR);
+      free(card_path);
+      if (dri2_dpy->fd < 0)
+         continue;
+
+      dri2_dpy->driver_name = loader_get_driver_for_fd(dri2_dpy->fd, 0);
+      if (dri2_dpy->driver_name) {
+         if (dri2_load_driver(disp)) {
+            driver_loaded = 1;
+            break;
+         }
+         free(dri2_dpy->driver_name);
+      }
+      close(dri2_dpy->fd);
+   }
+
+   if (!driver_loaded) {
+      err = "DRI2: failed to load driver";
+      goto cleanup_display;
+   }
+
+   dri2_dpy->dri2_loader_extension.base.name = __DRI_DRI2_LOADER;
+   dri2_dpy->dri2_loader_extension.base.version = 3;
+   dri2_dpy->dri2_loader_extension.getBuffers = NULL;
+   dri2_dpy->dri2_loader_extension.flushFrontBuffer =
+      null_flush_front_buffer;
+   dri2_dpy->dri2_loader_extension.getBuffersWithFormat =
+      null_get_buffers_with_format;
+
+   dri2_dpy->extensions[0] = &dri2_dpy->dri2_loader_extension.base;
+   dri2_dpy->extensions[1] = &image_lookup_extension.base;
+   dri2_dpy->extensions[2] = &use_invalidate.base;
+   dri2_dpy->extensions[3] = NULL;
+
+   if (!dri2_create_screen(disp)) {
+      err = "DRI2: failed to create screen";
+      goto cleanup_driver;
+   }
+
+   for (i = 0; dri2_dpy->driver_configs[i]; i++) {
+      EGLint attr_list[1];
+      attr_list[0] = EGL_NONE;
+      dri2_add_config(disp, dri2_dpy->driver_configs[i],
+                      i + 1, EGL_WINDOW_BIT, attr_list, NULL);
+   }
+
+   disp->Extensions.KHR_image_base = EGL_TRUE;
+
+   /* we're supporting EGL 1.4 */
+   disp->VersionMajor = 1;
+   disp->VersionMinor = 4;
+
+   /* Fill vtbl last to prevent accidentally calling virtual function during
+    * initialization.
+    */
+   dri2_dpy->vtbl = &dri2_null_display_vtbl;
+
+   return EGL_TRUE;
+
+cleanup_driver:
+   dlclose(dri2_dpy->driver);
+   free(dri2_dpy->driver_name);
+   close(dri2_dpy->fd);
+cleanup_display:
+   free(dri2_dpy);
+
+   return _eglError(EGL_NOT_INITIALIZED, err);
+}
-- 
2.2.0.rc0.207.ga3a616c

